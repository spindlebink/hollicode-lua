This is a Hollicode script testing environment. You can edit the script in `script.hlc`, then recompile it via the Hollicode compiler into `script.json`, then reload the LÖVE project.

> Top-level options

[option] Tell me about Hollicode.
	[if no_more_second_level_options]
		Well, you've been through the whole spiel already, so why not just scroll up and re-read it?
		-> Top-level options

	[else]
		Hollicode is a programming language for composing interactive narratives. It's designed to stay out of your way and let you write systemic, branching narratives in a way that reads like plain text most of the time.
	
		The Hollicode compiler is written in Crystal. It compiles Hollicode source into a super-simple, super-portable bytecode format which can be loaded in your game engine of choice. There's currently a full Lua-based interpreter available, but I've also got a mostly-complete GDScript interpreter in the works. Interpreter development happens on an as-needed basis for my personal projects.

	> Second-level options

	[if not no_more_second_level_options]
		[if not selected_integrate]
			[option] How do I integrate an interpreter into my game?
				# The `set` method is provided by the LOVE environment--it's not built into the interpreter.
				# All it does is set the specified variable to `true`. We then access that variable as a progress flag in this script.
				[set :selected_integrate]
				The interpreter doesn't do any displaying or input of its own. Instead, interpreters leave implementation details up to the developer. For example, the project you're running right now is mostly non-Hollicode-specific code for LÖVE that loads up a rich text buffer, display system, and input, then hooks that buffer in to interpreter callbacks. The interpreter's only in charge of program flow.
				-> Second-level options

		[if not selected_useful]
			[option] On what occasions would something like Hollicode be useful?
				[set :selected_useful]
				Anywhere that'd be improved with branching dialog. If you've ever used Ink or Yarnspinner, Hollicode is like a more ergonomic, more portable alternative.
				-> Second-level options

		[if not selected_performance]
			[option] Wait, isn't writing an interpreter in a scripting language going to be slow?
				[set :selected_performance]
				Ordinarily, maybe. But Hollicode's domain is highly limited. You shouldn't be writing your whole game's logic in Hollicode. Based on where you place options and wait for input, the interpreter will likely only be executing a couple dozen non-performance-sensitive instructions at a time.

				Hollicode intentionally doesn't provide a dedicated way to write functions or set variables, although both can be done with a little creativity. The intent is to offload game-specific logic to the game programmer. If you find yourself trying to emulate function-like structures in pure Hollicode, odds are you should instead implement that functionality in your game engine's scripting language of choice and hook into it from Hollicode instead.
				-> Second-level options

		[if selected_integrate and selected_useful and selected_performance]
			[set :no_more_second_level_options]
			I think that's it, as far as broader, conceptual questions go. Anything else?
			-> Top-level options
		[else]
			[option] I have something else to ask.
				-> Top-level options

		[wait]

[option] This seems kind of cool.
	Doesn't it? The language is in development for a game I'm working on called *Hollico*. That's where the name comes from. I suffer from an issue common to a lot of game developers--it's nearly as fun to make tooling as it is to make a real game. Hence a full compiler for something that could've just been done in script.

	Still, it makes future work much easier. And it's cool.
	-> Top-level options

[option] What's the license?
	The compiler itself (i.e. the Crystal code comprising it) is licensed under the Affero GPL, version 3.0. That means if you use the compiler directly from your project, you'll need to open source your project and also license it under the AGPL.

	If you don't like copyleft, don't worry: the generated bytecode isn't under the AGPL, and neither is the Lua interpreter in this repository. The interpreter's plain old MIT, and as for generated bytecode, that's your own.
	
	I'm of the opinion that all software should be open source (and copyleft), but I also try to be realistic. If you've got any questions about licensing, feel free to ask. Raise a GitHub issue, maybe.
	-> Top-level options

[wait]